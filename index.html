<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resolver $ref en YAML (Descarga Limpia y Validación cURL)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .content-area { 
            min-height: 200px;
            max-height: 350px; 
            overflow-y: auto;
            white-space: pre;
            font-family: monospace;
            background-color: #f9fafb; 
            border: 1px solid #e5e7eb; 
            border-radius: 0.375rem; 
            padding: 0.75rem; 
        }
        #resolvedContent {
            resize: vertical;
            min-height: 250px;
            max-height: 70vh; 
        }
        #curlValidationOutput { 
            white-space: pre-wrap;
        }
        #curlValidationOutput pre { 
            white-space: pre;
            word-wrap: normal; 
            overflow-x: auto; 
        }
        .content-area::-webkit-scrollbar, #usedFilesListContent::-webkit-scrollbar, #curlValidationOutput::-webkit-scrollbar, #apiSummaryContent::-webkit-scrollbar {
            width: 8px;
        }
        .content-area::-webkit-scrollbar-track, #usedFilesListContent::-webkit-scrollbar-track, #curlValidationOutput::-webkit-scrollbar-track, #apiSummaryContent::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .content-area::-webkit-scrollbar-thumb, #usedFilesListContent::-webkit-scrollbar-thumb, #curlValidationOutput::-webkit-scrollbar-thumb, #apiSummaryContent::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .message-box {
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            border-width: 1px;
        }
        .message-box-success { background-color: #d1fae5; color: #065f46; border-color: #6ee7b7; }
        .message-box-error { background-color: #fee2e2; color: #991b1b; border-color: #fca5a5; }
        .message-box-info { background-color: #e0f2fe; color: #075985; border-color: #7dd3fc; }
        .message-box-warning { background-color: #fef3c7; color: #92400e; border-color: #fcd34d; }

        #usedFilesListContent li { 
            padding: 0.35rem 0.6rem; 
            font-size: 0.8rem; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            font-family: monospace;
            cursor: pointer; 
            border-radius: 0.25rem;
        }
        #usedFilesListContent li:hover {
            background-color: #eef2ff; 
        }
        #usedFilesListContent li.selected {
            background-color: #c7d2fe; 
            font-weight: 500;
        }

        #mainFileSelector, #curlOperationPath, #curlOperationMethod { max-width: 100%; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); width: 24px; height: 24px; border-radius: 50%; border-left-color: #09f; animation: spin 1s ease infinite; display: inline-block; margin-right: 8px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #opConsultorSection { border: 1px solid #e5e7eb; border-radius: 0.5rem; padding: 1rem; margin-top: 1.5rem; }
        
        .resolved-yaml-line { padding: 1px 0; display: block; white-space: pre; }
        .source-annotation-line { color: #6b7280; font-size: 0.8em; font-style: italic; display: block; white-space: pre; padding: 1px 0; margin-top: 2px; margin-bottom: 2px; }
        .ref-original-line { color: #1d4ed8; font-weight: 500; }
        .bg-cycle-0 { background-color: #eff6ff; } .bg-cycle-1 { background-color: #f0fdf4; } .bg-cycle-2 { background-color: #fef9c3; } .bg-cycle-3 { background-color: #fce7f3; } .bg-cycle-4 { background-color: #f5f3ff; } .bg-cycle-5 { background-color: #fff7ed; } .bg-cycle-6 { background-color: #ecfeff; } .bg-cycle-7 { background-color: #f7fee7; } .bg-cycle-8 { background-color: #eef2ff; }
        .openapi-section-title-key .key-text { font-weight: 600; color: #1f2937; }
        .openapi-section-title-key { margin-top: 1em; padding-top: 0.75em; border-top: 1px dashed #d1d5db; }
        .openapi-section-title-key:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .openapi-path-key .key-text { font-weight: 600; color: #1e40af; }
        .openapi-path-key { margin-top: 0.5em; }
        .openapi-method-key .key-text { font-weight: 700; }
        .method-get .key-text { color: #059669; } .method-post .key-text { color: #2563eb; } .method-put .key-text { color: #d97706; } .method-delete .key-text { color: #dc2626; } .method-patch .key-text { color: #9333ea; } .method-options .key-text { color: #52525b; } .method-head .key-text { color: #52525b; } .method-trace .key-text { color: #52525b; } 
        
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: white; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 10px 25px rgba(0,0,0,0.1); text-align: center; max-width: 90%; width: 400px;}
        .modal-content p { margin-bottom: 1.5rem; font-size: 0.9rem; color: #4b5563; }
        .modal-buttons button { padding: 0.5rem 1rem; margin: 0 0.5rem; border-radius: 0.375rem; font-weight: 500; cursor: pointer; transition: background-color 0.2s; }
        .modal-confirm-button { background-color: #2563eb; color: white; }
        .modal-confirm-button:hover { background-color: #1d4ed8; }
        .modal-cancel-button { background-color: #e5e7eb; color: #374151; }
        .modal-cancel-button:hover { background-color: #d1d5db; }
        .openapi-feedback-section { margin-top: 1rem; padding-top: 0.75rem; border-top: 1px dotted #cbd5e1;}
        
        #usedFilesArea details > summary { cursor: pointer; font-weight: 600; padding: 0.25rem 0; }
        #usedFilesArea details[open] > summary { margin-bottom: 0.5rem; }

    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl w-full max-w-5xl">
        <header class="mb-6 text-center">
            <h1 class="text-2xl sm:text-3xl font-bold text-gray-800">Resolvedor de Referencias <code>$ref</code> en YAML</h1>
            <p class="text-sm text-gray-600 mt-1">Carga una carpeta, elige el archivo principal, resuélvelo, visualiza orígenes de forma interactiva y consulta a OP Consultor.</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 mb-4">
            <div>
                <label for="yamlDirectory" class="block mb-2 text-sm font-medium text-gray-700">1. Selecciona una carpeta con archivos YAML:</label>
                <input type="file" id="yamlDirectory" webkitdirectory directory multiple class="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
            </div>
            <div>
                <label for="mainFileSelector" class="block mb-2 text-sm font-medium text-gray-700">2. Selecciona el archivo principal de una carpeta "reference":</label>
                <select id="mainFileSelector" class="block w-full p-2 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500" disabled>
                    <option value="">-- Primero carga una carpeta --</option>
                </select>
            </div>
        </div>
        
        <div class="flex flex-col sm:flex-row justify-center items-center gap-4 mb-6">
            <button id="processButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed w-full sm:w-auto">
                Resolver $refs
            </button>
            <button id="downloadButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed w-full sm:w-auto">
                Descargar YAML Resuelto
            </button>
        </div>
        
        <div id="messageArea" class="mb-4"></div>

        <div class="mb-6">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">Contenido YAML Resuelto (Interactivo)</h2>
            <div id="resolvedContent" class="content-area text-xs"></div> 
        </div>
        
        <div id="usedFilesArea" class="mt-2 mb-6 hidden">
            <details>
                <summary class="text-md font-semibold text-gray-700 hover:text-blue-600">Archivos Utilizados en la Resolución (clic para expandir)</summary>
                <div class="flex items-center mt-2">
                    <ul id="usedFilesListContent" class="p-2 text-sm flex-grow"></ul>
                    <button id="viewSelectedUsedFileButton" class="ml-3 bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-1 px-3 rounded-lg text-xs disabled:opacity-50 disabled:cursor-not-allowed">Ver Archivo</button>
                </div>
            </details>
        </div>
        
        <div id="opConsultorSection">
            <h2 class="text-xl font-semibold text-gray-800 mb-3 text-center">OP Consultor: Validador de cURL</h2>
             <div class="mb-4">
                <label for="geminiApiKeyInput" class="block mb-2 text-sm font-medium text-gray-700">API Key para OP Consultor:</label>
                <input type="password" id="geminiApiKeyInput" placeholder="Pega tu API Key aquí" class="block w-full p-2 text-sm text-gray-900 border border-gray-300 rounded-lg bg-gray-50 focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500">
            </div>
            
            <div id="curlValidatorTab" class="op-consultor-tab-content" style="border-top: none; padding-top: 0;">
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-3">
                    <div>
                        <label for="curlOperationPath" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Path:</label>
                        <select id="curlOperationPath" class="block w-full p-2 text-sm border border-gray-300 rounded-lg bg-gray-50" disabled></select>
                    </div>
                    <div>
                        <label for="curlOperationMethod" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Método:</label>
                        <select id="curlOperationMethod" class="block w-full p-2 text-sm border border-gray-300 rounded-lg bg-gray-50" disabled></select>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="curlCommandInput" class="block text-sm font-medium text-gray-700 mb-1">Comando cURL a Validar:</label>
                    <textarea id="curlCommandInput" rows="8" class="block w-full p-2 text-sm border border-gray-300 rounded-lg bg-gray-50 focus:ring-blue-500 focus:border-blue-500" placeholder="Pega tu comando cURL aquí..."></textarea>
                </div>
                <button id="validateCurlButton" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed w-full flex items-center justify-center">
                    <span id="curlValidatorSpinner" class="spinner hidden mr-2"></span>
                    Validar cURL con OP Consultor
                </button>
                <div id="curlValidationResultArea" class="mt-4 hidden">
                    <h4 class="text-md font-semibold text-gray-700 mb-2">Análisis de OP Consultor:</h4>
                    <div id="curlValidationOutput" class="content-area text-sm p-3 bg-white rounded-md border"></div>
                </div>
            </div>
        </div>
        
        <div id="confirmationModal" class="modal-overlay hidden">
            <div class="modal-content">
                <p id="confirmationMessage"></p>
                <div class="modal-buttons">
                    <button id="confirmActionButton" class="modal-confirm-button">Continuar</button>
                    <button id="cancelActionButton" class="modal-cancel-button">Cancelar</button>
                </div>
            </div>
        </div>

        <footer class="mt-8 text-center text-xs text-gray-500">
            <p>Utilizando js-yaml y OP Consultor. La selección de carpetas funciona mejor en navegadores basados en Chromium.</p>
        </footer>
    </div>

    <script>
        // Global State
        let loadedFilesData = {}; 
        let mainFileName = null;    
        const TARGET_REFERENCE_FOLDER_NAME = 'reference'; 
        let currentResolvedObject = null; 
        let filesUsedInResolution = new Set();
        const YAML_REF_ORIGIN_MARKER = '__yaml_ref_origin__';
        const RESOLVED_REF_MARKER = '__is_resolved_ref__'; 
        let currentConfirmAction = null;
        const GEMINI_MODEL_NAME = 'gemini-1.5-flash-latest'; 
        let selectedUsedFilePath = null;

        const blockColorClasses = ['bg-cycle-0', 'bg-cycle-1', 'bg-cycle-2', 'bg-cycle-3', 'bg-cycle-4', 'bg-cycle-5', 'bg-cycle-6', 'bg-cycle-7', 'bg-cycle-8'];
        const httpMethods = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
        const openApiTopLevelKeys = ["openapi", "info", "servers", "paths", "components", "security", "tags", "externalDocs"];

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') unsafe = String(unsafe);
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        document.addEventListener('DOMContentLoaded', () => {
            const yamlDirectoryInput = document.getElementById('yamlDirectory');
            const mainFileSelector = document.getElementById('mainFileSelector');
            const geminiApiKeyInput = document.getElementById('geminiApiKeyInput');
            const processButton = document.getElementById('processButton');
            const downloadButton = document.getElementById('downloadButton');
            
            const originalContentDiv = document.getElementById('originalContent'); 
            const resolvedContentDiv = document.getElementById('resolvedContent');
            const messageArea = document.getElementById('messageArea');
            
            const usedFilesArea = document.getElementById('usedFilesArea');
            const usedFilesListContent = document.getElementById('usedFilesListContent');
            const viewSelectedUsedFileButton = document.getElementById('viewSelectedUsedFileButton');
            
            const curlValidatorTab = document.getElementById('curlValidatorTab'); 
            const curlOperationPath = document.getElementById('curlOperationPath');
            const curlOperationMethod = document.getElementById('curlOperationMethod');
            const curlCommandInput = document.getElementById('curlCommandInput');
            const validateCurlButton = document.getElementById('validateCurlButton');
            const curlValidatorSpinner = document.getElementById('curlValidatorSpinner');
            const curlValidationResultArea = document.getElementById('curlValidationResultArea');
            const curlValidationOutput = document.getElementById('curlValidationOutput');

            const confirmationModal = document.getElementById('confirmationModal');
            const confirmationMessage = document.getElementById('confirmationMessage');
            const confirmActionButton = document.getElementById('confirmActionButton');
            const cancelActionButton = document.getElementById('cancelActionButton');

            function showMessage(type, text) {
                messageArea.innerHTML = ''; 
                const box = document.createElement('div');
                box.className = `message-box message-box-${type}`;
                box.textContent = text;
                messageArea.appendChild(box);
            }
            function clearMessages() { messageArea.innerHTML = ''; }

            function showConfirmationModal(message, onConfirm) {
                confirmationMessage.textContent = message;
                currentConfirmAction = onConfirm;
                confirmationModal.classList.remove('hidden');
            }
            confirmActionButton.addEventListener('click', () => {
                if (currentConfirmAction) currentConfirmAction();
                confirmationModal.classList.add('hidden');
                currentConfirmAction = null;
            });
            cancelActionButton.addEventListener('click', () => {
                confirmationModal.classList.add('hidden');
                currentConfirmAction = null;
                if (validateCurlButton) validateCurlButton.disabled = !currentResolvedObject || !curlOperationPath.value || !curlOperationMethod.value;
                if (curlValidatorSpinner) curlValidatorSpinner.classList.add('hidden');
            });

            function initializeUIState() {
                downloadButton.disabled = true;
                validateCurlButton.disabled = true;
                curlOperationPath.disabled = true;
                curlOperationMethod.disabled = true;
                viewSelectedUsedFileButton.disabled = true;

                if (curlValidatorTab) curlValidatorTab.classList.remove('hidden'); 
                if (curlValidationResultArea) curlValidationResultArea.classList.add('hidden');
                if (usedFilesArea) usedFilesArea.classList.add('hidden');
                
                if (usedFilesListContent) usedFilesListContent.innerHTML = '';
                if (curlValidationOutput) curlValidationOutput.innerHTML = '';
                if (curlCommandInput) curlCommandInput.value = '';
                selectedUsedFilePath = null;
            }
            
            function populateMainFileSelector() {
                mainFileSelector.innerHTML = ''; 
                const referenceFiles = [];
                for (const filePath in loadedFilesData) {
                    if (filePath.split('/').slice(0, -1).includes(TARGET_REFERENCE_FOLDER_NAME)) {
                        referenceFiles.push(filePath);
                    }
                }
                referenceFiles.sort();
                initializeUIState(); 

                if (referenceFiles.length > 0) {
                    referenceFiles.forEach(filePath => {
                        const option = document.createElement('option');
                        option.value = filePath; option.textContent = filePath; 
                        mainFileSelector.appendChild(option);
                    });
                    mainFileSelector.disabled = false;
                    mainFileName = referenceFiles[0];
                    mainFileSelector.value = mainFileName;
                    if (originalContentDiv) originalContentDiv.textContent = loadedFilesData[mainFileName]?.raw || '';
                    processButton.disabled = false;
                    showMessage('success', `Archivos YAML cargados. Selecciona un archivo de la carpeta "${TARGET_REFERENCE_FOLDER_NAME}" para procesar.`);
                } else {
                    const option = document.createElement('option');
                    option.value = ""; option.textContent = `-- No se encontraron archivos YAML en ninguna carpeta "${TARGET_REFERENCE_FOLDER_NAME}" --`;
                    mainFileSelector.appendChild(option);
                    mainFileSelector.disabled = true; mainFileName = null;
                    if (originalContentDiv) originalContentDiv.textContent = '';
                    processButton.disabled = true;
                    if (Object.keys(loadedFilesData).length > 0) { 
                         showMessage('info', `Se cargaron archivos YAML, pero ninguno en una carpeta "${TARGET_REFERENCE_FOLDER_NAME}".`);
                    } else { 
                         showMessage('info', `No se cargaron archivos YAML. Primero selecciona una carpeta.`);
                    }
                }
            }

            yamlDirectoryInput.addEventListener('change', async (event) => {
                const files = event.target.files;
                loadedFilesData = {}; mainFileName = null; currentResolvedObject = null;
                if (originalContentDiv) originalContentDiv.textContent = ''; 
                if (resolvedContentDiv) resolvedContentDiv.innerHTML = ''; 
                mainFileSelector.innerHTML = '<option value="">-- Primero carga una carpeta --</option>';
                mainFileSelector.disabled = true;
                clearMessages(); initializeUIState();

                if (!files || files.length === 0) return;

                let errors = []; let yamlFileCount = 0;
                for (const file of files) {
                    const filePath = file.webkitRelativePath; 
                    if (!filePath.toLowerCase().endsWith('.yaml') && !filePath.toLowerCase().endsWith('.yml')) continue; 
                    yamlFileCount++;
                    try {
                        const fileContent = await file.text(); 
                        loadedFilesData[filePath] = { raw: fileContent, parsed: jsyaml.load(fileContent) };
                    } catch (e) { errors.push(`Error al parsear "${filePath}": ${e.message}`); }
                }
                if (errors.length > 0) showMessage('error', `Algunos archivos YAML no pudieron ser parseados: \n${errors.join('\n')}`);
                if (yamlFileCount === 0) showMessage('info', 'No se encontraron archivos .yaml o .yml en la carpeta seleccionada.');
                populateMainFileSelector(); 
            });

            mainFileSelector.addEventListener('change', (event) => {
                mainFileName = event.target.value;
                currentResolvedObject = null; 
                if (resolvedContentDiv) resolvedContentDiv.innerHTML = '';
                initializeUIState(); 
                if (mainFileName && loadedFilesData[mainFileName]) {
                    if (originalContentDiv) originalContentDiv.textContent = loadedFilesData[mainFileName].raw;
                    processButton.disabled = false; clearMessages(); 
                } else {
                    if (originalContentDiv) originalContentDiv.textContent = ''; 
                    processButton.disabled = true; mainFileName = null; 
                }
            });

            function normalizePath(baseDir, relativePath) { 
                const baseParts = baseDir.split('/').filter(p => p.length > 0);
                const relativeParts = relativePath.split('/');
                let pathStack = [...baseParts];
                for (const part of relativeParts) {
                    if (part === '..') {
                        if (pathStack.length > 0) pathStack.pop();
                        else throw new Error(`Referencia inválida: "${relativePath}" intenta navegar por encima de la carpeta raíz desde "${baseDir}".`);
                    } else if (part !== '.' && part !== '') {
                        pathStack.push(part);
                    }
                }
                return pathStack.join('/');
            }
            function getPath(obj, pointer) { 
                const effectivePointer = pointer.startsWith('#/') ? pointer.substring(2) : (pointer.startsWith('/') ? pointer.substring(1) : pointer);
                if (effectivePointer === '') return obj;
                const parts = effectivePointer.split('/');
                let current = obj;
                for (const part of parts) {
                    const decodedPart = decodeURIComponent(part.replace(/~1/g, '/').replace(/~0/g, '~'));
                    if (current && typeof current === 'object' && decodedPart in current) {
                        current = current[decodedPart];
                    } else {
                        throw new Error(`Ruta de referencia no encontrada: "${pointer}". Parte fallida: "${decodedPart}" en el objeto.`);
                    }
                }
                return current;
            }
            function parseRefString(refString) { 
                const hashIndex = refString.indexOf('#');
                if (hashIndex === -1) return { filePath: refString, pointer: '#/' };
                if (hashIndex === 0) return { filePath: null, pointer: refString };
                return { filePath: refString.substring(0, hashIndex), pointer: refString.substring(hashIndex) };
            }
            function resolveReferences(currentValue, currentFileFullPath, allFilesData, visitedRefs, usedFilesSet) { 
                if (typeof currentValue !== 'object' || currentValue === null) {
                    return currentValue;
                }
                if (currentFileFullPath && !visitedRefs.has(currentFileFullPath + '#INTERNAL_VISIT_MARKER_YAML_RESOLVER')) { 
                     usedFilesSet.add(currentFileFullPath);
                     visitedRefs.add(currentFileFullPath + '#INTERNAL_VISIT_MARKER_YAML_RESOLVER'); 
                }
                if (Array.isArray(currentValue)) {
                    return currentValue.map(item => resolveReferences(item, currentFileFullPath, allFilesData, new Set(visitedRefs), usedFilesSet));
                }
                if (currentValue.hasOwnProperty('$ref')) {
                    const refString = currentValue.$ref;
                    if (typeof refString !== 'string') throw new Error(`Valor de $ref inválido: ${refString}.`);
                    const { filePath: refFilePathPart, pointer: refPointer } = parseRefString(refString);
                    let targetFileFullPath = refFilePathPart === null ? currentFileFullPath : normalizePath(currentFileFullPath.includes('/') ? currentFileFullPath.substring(0, currentFileFullPath.lastIndexOf('/') + 1) : "", refFilePathPart);
                    let targetDocumentParsed = allFilesData[targetFileFullPath]?.parsed;
                    if (!targetDocumentParsed) throw new Error(`Archivo referenciado no cargado: "${targetFileFullPath}" (desde $ref: "${refString}" en "${currentFileFullPath}").`);
                    usedFilesSet.add(targetFileFullPath); 
                    const fullRefIdentifier = targetFileFullPath + refPointer;
                    if (visitedRefs.has(fullRefIdentifier)) throw new Error(`Referencia circular detectada para: "${fullRefIdentifier}"`);
                    visitedRefs.add(fullRefIdentifier);
                    let resolvedPart = getPath(targetDocumentParsed, refPointer); 
                    let clonedResolvedPart = JSON.parse(JSON.stringify(resolvedPart));
                    const fullyResolvedContent = resolveReferences(clonedResolvedPart, targetFileFullPath, allFilesData, new Set(visitedRefs), usedFilesSet);
                    const refWrapper = {};
                    Object.defineProperty(refWrapper, RESOLVED_REF_MARKER, { value: true, enumerable: false });
                    Object.defineProperty(refWrapper, 'originalRefString', { value: refString, enumerable: false });
                    Object.defineProperty(refWrapper, 'resolvedContent', { value: fullyResolvedContent, enumerable: false });
                    if (refFilePathPart !== null) Object.defineProperty(refWrapper, 'sourceFile', { value: targetFileFullPath, enumerable: false });
                    if (targetFileFullPath !== currentFileFullPath && targetFileFullPath !== mainFileName) Object.defineProperty(refWrapper, YAML_REF_ORIGIN_MARKER, { value: targetFileFullPath, enumerable: false });
                    return refWrapper;
                }
                const newObj = {};
                let isExternalBlock = currentFileFullPath !== mainFileName;
                for (const key in currentValue) {
                    if (Object.prototype.hasOwnProperty.call(currentValue, key)) { 
                        if (key === YAML_REF_ORIGIN_MARKER || key === RESOLVED_REF_MARKER) continue;
                        newObj[key] = resolveReferences(currentValue[key], currentFileFullPath, allFilesData, new Set(visitedRefs), usedFilesSet);
                    }
                }
                const existingOrigin = Object.getOwnPropertyDescriptor(currentValue, YAML_REF_ORIGIN_MARKER)?.value;
                if (existingOrigin) Object.defineProperty(newObj, YAML_REF_ORIGIN_MARKER, { value: existingOrigin, enumerable: false });
                else if (isExternalBlock) Object.defineProperty(newObj, YAML_REF_ORIGIN_MARKER, { value: currentFileFullPath, enumerable: false });
                return newObj;
            }
            function displayInteractiveResolvedYaml(dataToDisplay, parentElement, indentLevel = 0, inheritedSource = null, refDepth = 0, parentKeyForContext = null) { 
                const indentSpaces = '  '.repeat(indentLevel);
                if (typeof dataToDisplay === 'object' && dataToDisplay !== null && Object.getOwnPropertyDescriptor(dataToDisplay, RESOLVED_REF_MARKER)?.value) {
                    const originalRef = Object.getOwnPropertyDescriptor(dataToDisplay, 'originalRefString').value;
                    const resolvedContent = Object.getOwnPropertyDescriptor(dataToDisplay, 'resolvedContent').value;
                    const sourceFile = Object.getOwnPropertyDescriptor(dataToDisplay, 'sourceFile')?.value; 
                    const details = document.createElement('details');
                    details.style.paddingLeft = `${indentLevel * 1.5}em`;
                    const summary = document.createElement('summary');
                    summary.className = 'ref-original-line';
                    summary.textContent = `${parentKeyForContext ? escapeHtml(parentKeyForContext) + ': ' : ''}$ref: "${escapeHtml(originalRef)}"`; 
                    details.appendChild(summary);
                    const contentBlock = document.createElement('div');
                    contentBlock.className = 'resolved-content-block';
                    contentBlock.classList.add(blockColorClasses[refDepth % blockColorClasses.length]);
                    if (sourceFile && sourceFile !== mainFileName) {
                        const annotationDiv = document.createElement('div');
                        annotationDiv.className = 'source-annotation-line';
                        annotationDiv.textContent = `${'  '.repeat(1)}# Origen: ${escapeHtml(sourceFile)}`; 
                        contentBlock.appendChild(annotationDiv);
                    }
                    displayInteractiveResolvedYaml(resolvedContent, contentBlock, 0, sourceFile || inheritedSource, refDepth + 1, null); 
                    details.appendChild(contentBlock);
                    parentElement.appendChild(details);
                } else if (Array.isArray(dataToDisplay)) {
                    const parentIsExternal = inheritedSource && inheritedSource !== mainFileName;
                    if (dataToDisplay.length === 0) {
                        const lineDiv = document.createElement('div');
                        lineDiv.className = 'resolved-yaml-line';
                        lineDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                        lineDiv.textContent = `[]`;
                        if(parentIsExternal && !parentElement.classList.contains('resolved-content-block')) lineDiv.classList.add('resolved-external-source-block');
                        parentElement.appendChild(lineDiv);
                    } else {
                        dataToDisplay.forEach(item => {
                            const itemSource = (typeof item === 'object' && item !== null) ? Object.getOwnPropertyDescriptor(item, YAML_REF_ORIGIN_MARKER)?.value : null;
                            const effectiveItemSource = itemSource || inheritedSource;
                            if (typeof item === 'object' && item !== null && Object.getOwnPropertyDescriptor(item, RESOLVED_REF_MARKER)?.value) {
                                const itemWrapperDiv = document.createElement('div'); 
                                itemWrapperDiv.className = 'resolved-yaml-line'; 
                                itemWrapperDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                                itemWrapperDiv.textContent = `- `; 
                                if(parentIsExternal && !itemSource && !parentElement.classList.contains('resolved-content-block')) itemWrapperDiv.classList.add('resolved-external-source-block');
                                parentElement.appendChild(itemWrapperDiv);
                                displayInteractiveResolvedYaml(item, itemWrapperDiv, 0, effectiveItemSource, refDepth, null); 
                            } else if (typeof item === 'object' && item !== null) {
                                const itemDashDiv = document.createElement('div');
                                itemDashDiv.className = 'resolved-yaml-line';
                                itemDashDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                                itemDashDiv.textContent = `- `;
                                if(parentIsExternal && !itemSource && !parentElement.classList.contains('resolved-content-block')) itemDashDiv.classList.add('resolved-external-source-block');
                                parentElement.appendChild(itemDashDiv);
                                displayInteractiveResolvedYaml(item, parentElement, indentLevel + 1, effectiveItemSource, refDepth, null);
                            } else {
                                const itemLineDiv = document.createElement('div');
                                itemLineDiv.className = 'resolved-yaml-line';
                                itemLineDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                                itemLineDiv.textContent = `- ${escapeHtml(item)}`;
                                if(parentIsExternal && !itemSource && !parentElement.classList.contains('resolved-content-block')) itemLineDiv.classList.add('resolved-external-source-block');
                                parentElement.appendChild(itemLineDiv);
                            }
                        });
                    }
                } else if (typeof dataToDisplay === 'object' && dataToDisplay !== null) {
                    const keys = Object.keys(dataToDisplay);
                    if (keys.length === 0) {
                        const lineDiv = document.createElement('div');
                        lineDiv.className = 'resolved-yaml-line';
                        lineDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                        lineDiv.textContent = `{}`;
                        if (inheritedSource && inheritedSource !== mainFileName && !parentElement.classList.contains('resolved-content-block')) lineDiv.classList.add('resolved-external-source-block');
                        parentElement.appendChild(lineDiv);
                    } else {
                        let firstKeyProcessed = (parentElement === resolvedContentDiv && indentLevel === 0); 
                        keys.forEach(key => {
                            const value = dataToDisplay[key];
                            const keyLineDiv = document.createElement('div');
                            keyLineDiv.className = 'resolved-yaml-line';
                            keyLineDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                            const keyTextSpan = document.createElement('span');
                            keyTextSpan.className = 'key-text'; 
                            keyTextSpan.textContent = escapeHtml(key);
                            if (indentLevel === 0 && openApiTopLevelKeys.includes(key)) {
                                keyLineDiv.classList.add('openapi-section-title-key');
                                if (!firstKeyProcessed && keyLineDiv !== parentElement.firstChild) { 
                                    keyLineDiv.style.borderTop = '1px dashed #d1d5db';
                                    keyLineDiv.style.paddingTop = '0.75em';
                                    keyLineDiv.style.marginTop = '1em';
                                }
                                firstKeyProcessed = false; 
                            } else if (parentKeyForContext === "paths" && key.startsWith('/')) { 
                                keyLineDiv.classList.add('openapi-path-key');
                            } else if (parentKeyForContext && parentKeyForContext.startsWith('/') && httpMethods.includes(key.toLowerCase())) {
                                 keyLineDiv.classList.add('openapi-method-key', `method-${key.toLowerCase()}`);
                            }
                            const valueSource = (typeof value === 'object' && value !== null) ? Object.getOwnPropertyDescriptor(value, YAML_REF_ORIGIN_MARKER)?.value : null;
                            const effectiveValueSource = valueSource || inheritedSource;
                             if (effectiveValueSource && effectiveValueSource !== mainFileName && !parentElement.classList.contains('resolved-content-block')) {
                            }

                            if (typeof value === 'object' && value !== null && Object.getOwnPropertyDescriptor(value, RESOLVED_REF_MARKER)?.value) {
                                keyLineDiv.appendChild(keyTextSpan);
                                keyLineDiv.append(`: `); 
                                parentElement.appendChild(keyLineDiv);
                                displayInteractiveResolvedYaml(value, parentElement, indentLevel + 1, effectiveValueSource, refDepth, key); 
                            } else if (typeof value === 'object' && value !== null) {
                                keyLineDiv.appendChild(keyTextSpan);
                                keyLineDiv.append(`:`);
                                parentElement.appendChild(keyLineDiv);
                                displayInteractiveResolvedYaml(value, parentElement, indentLevel + 1, effectiveValueSource, refDepth, key);
                            } else {
                                keyLineDiv.appendChild(keyTextSpan);
                                keyLineDiv.append(`: ${escapeHtml(value)}`);
                                parentElement.appendChild(keyLineDiv);
                            }
                        });
                    }
                } else { 
                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'resolved-yaml-line';
                    lineDiv.style.paddingLeft = `${indentLevel * 1.5}em`;
                    lineDiv.textContent = `${escapeHtml(dataToDisplay)}`;
                    if (inheritedSource && inheritedSource !== mainFileName && !parentElement.classList.contains('resolved-content-block')) lineDiv.classList.add('resolved-external-source-block');
                    parentElement.appendChild(lineDiv);
                }
            }
            
            // Function to generate YAML string WITHOUT comments for download
            function generateCleanYamlForDownload(node) {
                if (typeof node !== 'object' || node === null) {
                    return node;
                }
                if (Object.getOwnPropertyDescriptor(node, RESOLVED_REF_MARKER)?.value) {
                    // For download, we want the resolved content, not the wrapper
                    return generateCleanYamlForDownload(Object.getOwnPropertyDescriptor(node, 'resolvedContent').value);
                }

                let cleanedNode = Array.isArray(node) ? [] : {};
                for (const key in node) {
                    if (Object.prototype.hasOwnProperty.call(node, key)) {
                        // Skip internal markers
                        if (key === YAML_REF_ORIGIN_MARKER || key === RESOLVED_REF_MARKER) continue;
                        cleanedNode[key] = generateCleanYamlForDownload(node[key]);
                    }
                }
                return cleanedNode;
            }


            processButton.addEventListener('click', () => {
                if (!mainFileName || !loadedFilesData[mainFileName]) {
                    showMessage('error', 'No hay un archivo YAML principal seleccionado.'); return;
                }
                clearMessages(); 
                if (resolvedContentDiv) resolvedContentDiv.innerHTML = 'Procesando $refs...'; 
                currentResolvedObject = null; initializeUIState(); filesUsedInResolution.clear();

                setTimeout(() => {
                    try {
                        const objectToResolve = JSON.parse(JSON.stringify(loadedFilesData[mainFileName].parsed)); 
                        currentResolvedObject = resolveReferences(objectToResolve, mainFileName, loadedFilesData, new Set(), filesUsedInResolution);
                        if (resolvedContentDiv) displayInteractiveResolvedYaml(currentResolvedObject, resolvedContentDiv, 0, mainFileName, 0, "root"); 
                        
                        showMessage('success', '¡Referencias $ref resueltas exitosamente!');
                        validateCurlButton.disabled = !currentResolvedObject;
                        if(currentResolvedObject) populateCurlOperationSelectors(); 

                        downloadButton.disabled = false;
                        if (usedFilesArea && usedFilesListContent) { 
                            if (filesUsedInResolution.size > 0) {
                                usedFilesArea.classList.remove('hidden');
                                usedFilesListContent.innerHTML = '';
                                Array.from(filesUsedInResolution).sort().forEach(filePath => {
                                    const li = document.createElement('li'); 
                                    li.textContent = filePath;
                                    li.dataset.filePath = filePath; 
                                    li.addEventListener('click', () => {
                                        if (selectedUsedFilePath === filePath) { 
                                            li.classList.remove('selected');
                                            selectedUsedFilePath = null;
                                            viewSelectedUsedFileButton.disabled = true;
                                        } else {
                                            const currentlySelected = usedFilesListContent.querySelector('li.selected');
                                            if (currentlySelected) currentlySelected.classList.remove('selected');
                                            
                                            li.classList.add('selected');
                                            selectedUsedFilePath = filePath;
                                            viewSelectedUsedFileButton.disabled = false;
                                        }
                                    });
                                    usedFilesListContent.appendChild(li);
                                });
                            }
                        }
                    } catch (error) {
                        if (resolvedContentDiv) resolvedContentDiv.innerHTML = `<div class="p-2 text-red-600">Error: ${escapeHtml(error.message)}</div>`;
                        showMessage('error', `Error al resolver $refs: ${error.message}`);
                        console.error("Error resolving $refs:", error);
                        currentResolvedObject = null; initializeUIState();
                    }
                }, 10);
            });
            
            viewSelectedUsedFileButton.addEventListener('click', () => {
                if (selectedUsedFilePath && loadedFilesData[selectedUsedFilePath]) {
                    const fileContent = loadedFilesData[selectedUsedFilePath].raw;
                    const newWindow = window.open("", "_blank");
                    if(newWindow){
                        newWindow.document.write(`<pre>${escapeHtml(fileContent)}</pre>`);
                        newWindow.document.title = selectedUsedFilePath;
                        newWindow.document.close();
                    } else {
                        showMessage('error', 'No se pudo abrir una nueva ventana. Revisa la configuración de tu navegador (bloqueador de pop-ups).');
                    }
                } else {
                    showMessage('info', 'No hay un archivo seleccionado o el archivo no se pudo cargar.');
                }
            });

            function downloadTextFile(text, filename, mimeType) { 
                const blob = new Blob([text], { type: mimeType }); const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = filename;
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            }
            downloadButton.addEventListener('click', () => { 
                 if (!currentResolvedObject) { showMessage('info', 'Resuelve $refs para descargar.'); return; }
                try {
                    const cleanObjectForDownload = generateCleanYamlForDownload(currentResolvedObject);
                    const yamlString = jsyaml.dump(cleanObjectForDownload, { indent: 2, noRefs: true, sortKeys: false }); // sortKeys: false to maintain original order as much as possible
                    downloadTextFile(yamlString, `${mainFileName.replace(/\.ya?ml$/, '')}_resuelto.yaml`, 'application/x-yaml');
                    showMessage('success', 'Archivo YAML resuelto (limpio) generado para descarga.');
                } catch (e) { showMessage('error', `Error al generar descarga: ${e.message}`); console.error(e); }
            });
            function createCleanCloneForAI(obj) { 
                if (typeof obj !== 'object' || obj === null) return obj;
                if (Object.getOwnPropertyDescriptor(obj, RESOLVED_REF_MARKER)?.value) {
                    return createCleanCloneForAI(Object.getOwnPropertyDescriptor(obj, 'resolvedContent').value);
                }
                let clone = Array.isArray(obj) ? [] : {};
                for (const key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) { 
                        if (key === YAML_REF_ORIGIN_MARKER || key === RESOLVED_REF_MARKER) continue; 
                        clone[key] = createCleanCloneForAI(obj[key]);
                    }
                }
                return clone;
            }
            
            function populateCurlOperationSelectors() {
                curlOperationPath.innerHTML = '<option value="">-- Selecciona un Path --</option>';
                curlOperationMethod.innerHTML = '<option value="">-- Selecciona un Método --</option>';
                curlOperationMethod.disabled = true;
                validateCurlButton.disabled = true;

                const cleanObjectForSelectors = createCleanCloneForAI(currentResolvedObject); // Use clean object for path/method population
                if (!cleanObjectForSelectors || !cleanObjectForSelectors.paths) return;


                const paths = Object.keys(cleanObjectForSelectors.paths);
                paths.sort().forEach(path => {
                    const option = document.createElement('option');
                    option.value = path; option.textContent = path;
                    curlOperationPath.appendChild(option);
                });
                curlOperationPath.disabled = false;
            }

            curlOperationPath.addEventListener('change', () => {
                const selectedPath = curlOperationPath.value;
                curlOperationMethod.innerHTML = '<option value="">-- Selecciona un Método --</option>';
                curlOperationMethod.disabled = true;
                validateCurlButton.disabled = true;

                const cleanObjectForSelectors = createCleanCloneForAI(currentResolvedObject);
                if (selectedPath && cleanObjectForSelectors.paths[selectedPath]) {
                    const methods = Object.keys(cleanObjectForSelectors.paths[selectedPath]).filter(m => httpMethods.includes(m.toLowerCase()));
                    if (methods.length > 0) {
                        methods.sort().forEach(method => {
                            const option = document.createElement('option');
                            option.value = method; option.textContent = method.toUpperCase();
                            curlOperationMethod.appendChild(option);
                        });
                        curlOperationMethod.disabled = false;
                    }
                }
            });
            curlOperationMethod.addEventListener('change', () => {
                validateCurlButton.disabled = !curlOperationPath.value || !curlOperationMethod.value;
            });

            async function handleValidateCurl() {
                const userApiKey = geminiApiKeyInput.value.trim();
                if (!userApiKey) { showMessage('error', 'Ingresa tu API Key para OP Consultor.'); geminiApiKeyInput.focus(); return; }
                
                const selectedPath = curlOperationPath.value;
                const selectedMethod = curlOperationMethod.value;
                const userCurlCommand = curlCommandInput.value.trim();

                if (!selectedPath || !selectedMethod) { showMessage('error', 'Selecciona un Path y Método.'); return; }
                if (!userCurlCommand) { showMessage('error', 'Ingresa el comando cURL a validar.'); curlCommandInput.focus(); return; }
                if (!currentResolvedObject) { showMessage('info', 'Resuelve $refs primero.'); return; }

                const cleanSpecForAI = createCleanCloneForAI(currentResolvedObject); // Use cleaned spec for AI context
                const operationDefinition = cleanSpecForAI.paths?.[selectedPath]?.[selectedMethod];
                if (!operationDefinition) { showMessage('error', 'Definición de operación no encontrada en el objeto limpio.'); return; }

                let relevantSchemas = {};
                function extractSchemas(obj) { 
                    if (typeof obj !== 'object' || obj === null) return;
                    if (obj.$ref && typeof obj.$ref === 'string' && obj.$ref.startsWith('#/components/schemas/')) {
                        const schemaName = obj.$ref.substring('#/components/schemas/'.length);
                        if (cleanSpecForAI.components?.schemas?.[schemaName] && !relevantSchemas[schemaName]) {
                            relevantSchemas[schemaName] = cleanSpecForAI.components.schemas[schemaName];
                            extractSchemas(relevantSchemas[schemaName]); 
                        }
                    }
                    for (const key in obj) if (obj.hasOwnProperty(key)) extractSchemas(obj[key]);
                }
                extractSchemas(operationDefinition); 
                
                const apiInfo = cleanSpecForAI.info || { title: "API Desconocida", version: "N/A" };
                const globalSecurity = cleanSpecForAI.security || [];
                const securitySchemes = cleanSpecForAI.components?.securitySchemes || {};

                const promptForCurlValidation = `Eres OP Consultor, un validador experto de comandos cURL y analista de especificaciones OpenAPI.
Tu tarea tiene dos partes principales:

PARTE 1: Validación del Comando cURL del Usuario
1.  La especificación OpenAPI proporcionada es la "fuente de la verdad". Analiza la definición de la operación OpenAPI y los componentes/esquemas relevantes.
2.  Valida el comando cURL proporcionado por el usuario ESTRICTAMENTE contra esta definición de operación.
3.  Enfócate en:
    * La estructura general del comando cURL (método, URL base, path).
    * La presencia y correcta especificación de todos los parámetros OBLIGATORIOS definidos en la OpenAPI (path, query, header).
    * La correcta ubicación de los parámetros (ej. un parámetro de path en el path, un header en las cabeceras -H, un parámetro de query en la URL).
    * Si hay un cuerpo de solicitud (requestBody), verifica que el comando cURL lo incluya correctamente (ej. con -d o --data) y que su estructura general sea consistente con lo esperado.
    * Es aceptable que el usuario utilice placeholders para los valores (ej. <TOKEN_AQUI>). No invalides el comando solo por placeholders; enfócate en nombres, obligatoriedad y ubicación.
4.  Determina si el comando del usuario es VÁLIDO (fiel a la especificación) o INVÁLIDO.
5.  Proporciona una EXPLICACIÓN clara y concisa en español para esta validación.
6.  Opcionalmente, genera un comando cURL "sugerido" si el del usuario es inválido y puedes proponer uno que sí cumpla la especificación.

PARTE 2: Análisis de la Especificación OpenAPI para la Operación
1.  Independientemente de la validez del cURL del usuario, analiza la definición de la operación OpenAPI proporcionada.
2.  Identifica si hay alguna alerta, ambigüedad, información faltante o inconsistencia en la propia documentación OpenAPI para esta operación que podría dificultar la creación de un comando cURL correcto o la comprensión de la operación. Es crucial que señales cualquier suposición que debas hacer debido a documentación incompleta o ambigua, ya que el usuario basa su comando cURL en su interpretación directa de la especificación.
3.  Si encuentras alertas, detalla cuáles son en una explicación concisa. Si no hay alertas, indícalo claramente.

Información de la API:
Título: ${apiInfo.title}
Versión: ${apiInfo.version}

Definición de la Operación (${selectedMethod.toUpperCase()} ${selectedPath}):
\`\`\`yaml
${jsyaml.dump(operationDefinition, { indent: 2, noRefs: true })}
\`\`\`

Esquemas Relevantes (de #/components/schemas/):
\`\`\`yaml
${Object.keys(relevantSchemas).length > 0 ? jsyaml.dump(relevantSchemas, { indent: 2, noRefs: true }) : 'Ninguno directamente referenciado en esta operación.'}
\`\`\`

Esquemas de Seguridad Globales y Definiciones (de #/components/securitySchemes/):
Seguridad Global Aplicada: ${jsyaml.dump(globalSecurity, { indent:2, noRefs: true})}
Definiciones de Esquemas de Seguridad:
\`\`\`yaml
${Object.keys(securitySchemes).length > 0 ? jsyaml.dump(securitySchemes, { indent: 2, noRefs: true }) : 'Ninguno definido.'}
\`\`\`

Comando cURL del Usuario a Validar:
\`\`\`
${userCurlCommand}
\`\`\`

Responde en formato JSON con la siguiente estructura:
{
  "curlValidation": {
    "isValid": boolean,
    "explanation": "string en español",
    "suggestedCurl": "string (opcional)"
  },
  "openapiSpecFeedback": {
    "hasAlerts": boolean,
    "alertsExplanation": "string en español (si hasAlerts es true, de lo contrario un mensaje como 'No se encontraron alertas específicas en la documentación para esta operación.')"
  }
}
`;
                const tokenCount = await countTokensWithGemini(promptForCurlValidation, userApiKey);
                if (tokenCount === null) { validateCurlButton.disabled = false; curlValidatorSpinner.classList.add('hidden'); return; }

                showConfirmationModal(
                    `OP Consultor procesará aproximadamente ${tokenCount} tokens de entrada para validar el cURL. ¿Deseas continuar?`,
                    async () => { 
                        showMessage('info', 'Validando comando cURL con OP Consultor...');
                        curlValidationResultArea.classList.remove('hidden');
                        curlValidationOutput.innerHTML = '<div class="p-2">Procesando con OP Consultor...</div>';
                        curlValidatorSpinner.classList.remove('hidden'); validateCurlButton.disabled = true;
                        await callGeminiForCurlValidation(promptForCurlValidation, userApiKey);
                        curlValidatorSpinner.classList.add('hidden'); validateCurlButton.disabled = !(!currentResolvedObject || !curlOperationPath.value || !curlOperationMethod.value);
                    }
                );
            }
            validateCurlButton.addEventListener('click', handleValidateCurl);

            async function callGeminiForCurlValidation(prompt, apiKey) {
                const payload = { 
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { responseMimeType: "application/json" } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:generateContent?key=${apiKey}`;
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) { 
                        let errMsg = `Error de OP Consultor (Validación cURL): ${response.statusText}`;
                        try { const errData = await response.json(); console.error('Error API (cURL):', errData); if (response.status === 429) { errMsg = `Error API: Cuota excedida (429). Revisa tu plan.`; if (errData.error?.details) { const r = errData.error.details.find(d => d['@type'] === 'type.googleapis.com/google.rpc.RetryInfo'); if (r?.retryDelay) errMsg += ` Intenta en ${r.retryDelay.replace('s',' seg')}.`;}} else if (errData.error?.message) errMsg = `Error API: ${errData.error.message}`; } catch(e){} throw new Error(errMsg);
                    }
                    const result = await response.json();
                    if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                        const jsonResponseText = result.candidates[0].content.parts[0].text;
                        try {
                            const validationResult = JSON.parse(jsonResponseText);
                            let outputHtml = '<div class="report-section">';
                            const cv = validationResult.curlValidation;
                            outputHtml += `<h5 class="report-title"><span class="status-icon ${cv.isValid ? 'status-valid' : 'status-invalid'}"></span>Reporte de Fidelidad del cURL: ${cv.isValid ? 'VÁLIDO' : 'INVÁLIDO'}</h5>`;
                            outputHtml += `<p>${escapeHtml(cv.explanation).replace(/\n/g, '<br>')}</p>`;
                            if (cv.suggestedCurl) {
                                outputHtml += `<p class="mt-2 mb-1"><strong>Comando cURL Sugerido:</strong></p><pre class="bg-gray-100 p-2 rounded text-xs whitespace-pre break-all">${escapeHtml(cv.suggestedCurl)}</pre>`;
                            }
                            outputHtml += '</div>';

                            const sf = validationResult.openapiSpecFeedback;
                            if (sf) {
                                outputHtml += '<div class="report-section openapi-feedback-section">';
                                outputHtml += `<h5 class="report-title"><span class="status-icon ${sf.hasAlerts ? 'status-alerts' : 'status-no-alerts'}"></span>Reporte de Alertas sobre Especificación OpenAPI: ${sf.hasAlerts ? 'CON ALERTAS' : 'SIN ALERTAS ESPECÍFICAS'}</h5>`;
                                outputHtml += `<p>${escapeHtml(sf.alertsExplanation).replace(/\n/g, '<br>')}</p>`;
                                outputHtml += '</div>';
                            }
                            
                            let conclusionText = "";
                            if (cv.isValid && sf && !sf.hasAlerts) {
                                conclusionText = "El comando cURL es fiel a la especificación y no se detectaron alertas mayores en la documentación de la operación.";
                            } else if (cv.isValid && sf && sf.hasAlerts) {
                                conclusionText = "El comando cURL es fiel a la especificación actual, pero OP Consultor ha detectado algunas alertas o áreas de mejora en la documentación de la operación que podrían ser relevantes.";
                            } else if (!cv.isValid && sf && !sf.hasAlerts) {
                                conclusionText = "El comando cURL no es fiel a la especificación. La documentación de la operación parece adecuada para la validación, pero el comando necesita ajustes.";
                            } else if (!cv.isValid && sf && sf.hasAlerts){ 
                                conclusionText = "El comando cURL no es fiel a la especificación, y además, OP Consultor ha detectado alertas en la documentación de la operación que podrían estar contribuyendo a la confusión o a los errores.";
                            } else if (!cv.isValid) { 
                                conclusionText = "El comando cURL no es fiel a la especificación.";
                            } else { 
                                conclusionText = "Análisis completado. Revisa los reportes individuales."
                            }
                            outputHtml += `<div class="report-section" style="border-bottom: none; margin-top: 1rem;"><h5 class="report-title">Conclusión General:</h5><p>${conclusionText}</p></div>`;

                            curlValidationOutput.innerHTML = outputHtml;
                            showMessage('success', 'Análisis de OP Consultor completado.');
                        } catch (e) {
                            console.error("Error parseando JSON de validación:", e, "\nTexto recibido:", jsonResponseText);
                            curlValidationOutput.innerHTML = `<p class="text-red-600">Error: OP Consultor no devolvió un JSON válido.</p><p class="text-xs mt-2">Respuesta cruda:<br><pre class="whitespace-pre-wrap break-all">${escapeHtml(jsonResponseText)}</pre></p>`;
                            showMessage('error', 'Error procesando respuesta de OP Consultor.');
                        }
                    } else { throw new Error('Respuesta inesperada de OP Consultor para validación cURL.'); }
                } catch (error) {
                    curlValidationOutput.innerHTML = `<p class="text-red-600">${error.message}</p>`; 
                    showMessage('error', error.message); console.error(error);
                }
            }

            async function countTokensWithGemini(promptText, apiKey) { 
                const payload = { contents: [{ role: "user", parts: [{ text: promptText }] }] };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:countTokens?key=${apiKey}`;
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!response.ok) {
                        let errMsg = `Error al contar tokens: ${response.statusText}`;
                        try { const errData = await response.json(); console.error('Error API (countTokens):', errData); 
                            if (errData.error && errData.error.message && (errData.error.message.toLowerCase().includes("api key not valid") || errData.error.message.toLowerCase().includes("api key expired")) ) {
                                errMsg = "Error al contar tokens: La API Key proporcionada no es válida o ha caducado. Por favor, verifica la clave e inténtalo de nuevo.";
                            } else if (response.status === 429) { 
                                errMsg = `Error al contar tokens: Has excedido tu cuota (Error 429).`;
                                if (errData.error?.details) { const r = errData.error.details.find(d => d['@type'] === 'type.googleapis.com/google.rpc.RetryInfo'); if (r?.retryDelay) errMsg += ` Intenta en ${r.retryDelay.replace('s',' seg')}.`;}
                            } else if (errData.error?.message) {
                               errMsg = `Error al contar tokens: ${errData.error.message}`;
                            }
                        } catch(e){ /* Failed to parse JSON error body */ }
                        showMessage('error', errMsg); 
                        return null;
                    }
                    const result = await response.json();
                    return result.totalTokens || null;
                } catch (error) {
                    showMessage('error', `Error de red al contar tokens: ${error.message}`); console.error(error); return null;
                }
            }
            
            populateMainFileSelector(); 
            if (curlValidatorTab) curlValidatorTab.classList.remove('hidden');


        });
    </script>
</body>
</html>